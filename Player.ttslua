local Archive = require("Kdm/Archive")
local Armor = require("Kdm/Armor")
local Check = require("Kdm/Util/Check")
local Container = require("Kdm/Util/Container")
local EventManager = require("Kdm/Util/EventManager")
local Location = require("Kdm/Location")
local log = require("Kdm/Log").ForModule("Player")
local NamedObject = require("Kdm/NamedObject")
local Survivor = require("Kdm/Survivor")
local Ui = require("Kdm/Ui")
local Util = require("Kdm/Util/Util")
local Weapon = require("Kdm/Weapon")

---------------------------------------------------------------------------------------------------

local Player = {}
Player.__index = Player
function Player.Is(x) return getmetatable(x) == Player end

Player.HIT_LOCATIONS = { "head", "arms", "body", "waist", "legs" }

Player.TOKENS = {
    ["Movement Token"] = true,
    ["Speed Token"] = true,
    ["Accuracy Token"] = true,
    ["Strength Token"] = true,
    ["Evasion Token"] = true,
    ["Luck Token"] = true,
    ["Bleeding Token"] = true,
    ["Lunacy Token"] = true,
    ["Reroll Token"] = true,
}

Player.TOKEN_STATS = {
    ["Movement Token"] = "movement",
    ["Speed Token"] = "speed",
    ["Accuracy Token"] = "accuracy",
    ["Strength Token"] = "strength",
    ["Evasion Token"] = "evasion",
    ["Luck Token"] = "luck",
}

---------------------------------------------------------------------------------------------------

function Player.Init(saveState)
    Player.players = {}
    for ordinal = 1, 4 do
        Player.players[ordinal] = Player.Create(ordinal, saveState[ordinal] or {})
    end
end

---------------------------------------------------------------------------------------------------

function Player.PostInit()
    for _, player in ipairs(Player.players) do
        player:UpdateGear()
        player:UpdateStats()
    end

    EventManager.AddHandler("onObjectCollisionEnter", Player.OnObjectCollisionEnter)
    EventManager.AddHandler("onObjectEnterContainer", Player.OnObjectEnterContainer)
    EventManager.AddHandler("onObjectDestroy", Player.OnObjectDestroy)
    EventManager.AddHandler(EventManager.ON_SURVIVOR_STAT_CHANGED, Player.OnSurvivorChangeStat)
    EventManager.AddHandler(EventManager.ON_PLAYER_COLOR_CHANGED, Player.OnPlayerColorChanged)

    Wait.time(function()
        for ordinal, player in ipairs(Player.players) do
            local playerMarker = NamedObject.Get("Player "..ordinal.." Marker")
            if playerMarker then
                local colorTable = playerMarker.getColorTint()
                local colorStr = "#"..Color(colorTable):toHex()
                EventManager.FireEvent(EventManager.ON_PLAYER_COLOR_CHANGED, player, colorTable, colorStr)
            end
        end
    end, 2, -1)
end

---------------------------------------------------------------------------------------------------

function Player.Save()
    local saveState = {}
    for i, player in ipairs(Player.players) do
        local playerSaveState = {}

        if player.survivorSheet then
            playerSaveState.survivorSheetGuid = player.survivorSheet:Object().getGUID()
        end

        if player.figurineObject then
            playerSaveState.figurineGuid = player.figurineObject.getGUID()
        end

        playerSaveState.temporaryArmor = player.temporaryArmor
        playerSaveState.injuries = player.injuries

        table.insert(saveState, playerSaveState)
    end
    return saveState
end

---------------------------------------------------------------------------------------------------

function Player.ForFigurine(figurineObject)
    for _, player in ipairs(Player.players) do
        if player.figurineObject == figurineObject then
            return player
        end
    end
end

---------------------------------------------------------------------------------------------------

function Player.OnObjectCollisionEnter(object, collisionInfo)
    -- This is a hack to detect flipped tokens
    -- There's no onFlip event, and flipping doesn't trigger onPickUp, so we rely on this to detect flips
    -- of *already registered* tokens.

    local collisionObject = collisionInfo.collision_object

    local player = nil
    for _, p in ipairs(Player.players) do
        if p.boardObject == collisionObject then
            player = p
            break
        end
    end
    if not player then
        return
    end

    log:Debugf("[%s]%s collided with [%s]%s", object.getGUID(), object.getName(), collisionObject.getGUID(), collisionObject.getName())

    local playerPrefix = "Player "..player.ordinal
    local temporaryTokensLocation = Location.Get(playerPrefix.." Temporary Tokens")
    local permanentTokensLocation = Location.Get(playerPrefix.." Permanent Tokens")
    local gearLocation = Location.Get(playerPrefix.." Gear")

    for _, location in ipairs(Location.ObjectLocations(object)) do
        if location == temporaryTokensLocation or location == permanentTokensLocation then
            log:Debugf("Token [%s]%s found in %s, updating stats", object.getGUID(), object.getName(), location)
            player:UpdateStats()
            break
        elseif location == gearLocation then
            log:Debugf("Token [%s]%s found in %s, updating gear", object.getGUID(), object.getName(), location)
            player:UpdateGear()
            break
        end
    end
end

---------------------------------------------------------------------------------------------------

function Player.OnObjectEnterContainer(container, object)
    local player = Player.ForFigurine(object)
    if player then
        player:UnlinkFigurine(object)
    end
end

---------------------------------------------------------------------------------------------------

function Player.OnObjectDestroy(object)
    for _, player in ipairs(Player.players) do
        if player.survivorSheet and player.survivorSheet:Object() == object then
            player:UnlinkSurvivorSheet()
            break
        end
    end

    local player = Player.ForFigurine(object)
    if player then
        player:UnlinkFigurine(object)
    end
end

---------------------------------------------------------------------------------------------------

function Player.OnSurvivorChangeStat(survivor, stat, value)
    if stat == "name" then
        for _, player in ipairs(Player.players) do
            if player.survivorSheet and player.survivorSheet:Survivor() == survivor and player.figurineObject then
                log:Debugf("Updating figurine [%s] name for %s to %s", player.figurineObject.getGUID(), player, value)
                player.figurineObject.setName(value)
            end
        end
    end
end

---------------------------------------------------------------------------------------------------

function Player.OnPlayerColorChanged(player, colorTable, colorStr)
    if player.figurineObject then
        player.figurineObject.setColorTint(colorTable)
    end
end

---------------------------------------------------------------------------------------------------

function Player.Create(ordinal, params)
    local playerPrefix = "Player "..ordinal

    local player = {
        tag = "Player",
        ordinal = ordinal,
        boardObject = NamedObject.Get(playerPrefix.." Board"),
        markerObject = NamedObject.Get(playerPrefix.." Marker"),
        weapons = {},   -- purely a concession to make BattleUi updates easier
    }
    setmetatable(player, Player)

    local playerPrefix = "Player "..player.ordinal

    if params.survivorSheetGuid then
        local survivorSheetObject = getObjectFromGUID(params.survivorSheetGuid)
        if survivorSheetObject == nil then  -- compare nil for TTS objects
            log:Errorf("Can't find survivor sheet %s that %d was linked to! Try recreating the it from the Population screen and dropping it back onto the player board.", params.linkedSurvivorSheetGuid, ordinal)
        else
            player.survivorSheet = Survivor.SurvivorSheetForObject(survivorSheetObject)
            if not player.survivorSheet then
                log:Errorf("Survivor sheet %s on player board %d wasn't linked to any survivor.", survivorSheetObject.getGUID(), ordinal)
            else
                log:Debugf("Linked %s to %s", player.survivorSheet, player)
            end
        end
    end

    if params.figurineGuid then
        figurineObject = getObjectFromGUID(params.figurineGuid)
        if not figurineObject then
            log:Errorf("Player %s was linked to figurine %s, but that object was deleted.", ordinal, params.figurineGuid)
        else
            player:LinkFigurine(figurineObject)
        end
    end

    player.temporaryArmor = {}
    player.lightInjuries = {}
    player.heavyInjuries = {}
    local paramsTemporaryArmor = params.temporaryArmor or {}
    local paramsLightInjuries = params.lightInjuries or {}
    local paramsHeavyInjuries = params.heavyInjuries or {}
    for _, hitLocation in ipairs(Player.HIT_LOCATIONS) do
        player.temporaryArmor[hitLocation] = paramsTemporaryArmor[hitLocation] or 0
        player.lightInjuries[hitLocation] = paramsLightInjuries[hitLocation]
        player.heavyInjuries[hitLocation] = paramsHeavyInjuries[hitLocation]
    end

    player.gear = {}
    local playerGearPrefix = playerPrefix.." Gear "
    for i = 1, 9 do
        player.gear[Location.Get(playerGearPrefix..i)] = {
            weapon = nil,
            armor = nil,
            tokens = {},
        }
    end
    player.gear[Location.Get(playerPrefix.." Fist & Tooth")] = {
        weapon = nil,
        armor = nil,
        tokens = {},
    }

    player:InitUi()

    local playerPrefix = "Player "..player.ordinal

    Location.Get(playerPrefix.." Survivor Sheet"):AddDropHandler(function(object)
        player:OnObjectDroppedOnSurvivorSheet(object)
    end)

    Location.Get(playerPrefix.." Marker"):AddDropHandler(function(object)
        if object.getGMNotes() == "Player Figurine" then
            player:LinkFigurine(object)
        end
    end)

    local checkUnregisterCollisions = function(object)
        if object and object.getGMNotes() == "Tokens" and Player.TOKEN_STATS[object.getName()] then
            log:Debugf("Unregistering token [%s]%s for collisions", object.getGUID(), object.getName())
            object.unregisterCollisions()
        end
    end

    local gearLocation = Location.Get(playerPrefix.." Gear")
    gearLocation:AddDropHandler(function(object, location)
        player:UpdateGear(object)
    end)
    gearLocation:AddPickUpHandler(function(object, location)
        checkUnregisterCollisions(object)
        player:UpdateGear(object)
    end)

    local cardsLocation = Location.Get(playerPrefix.." Cards")
    cardsLocation:AddDropHandler(function(object)
        player:UpdateCards()
    end)
    cardsLocation:AddPickUpHandler(function(object)
        player:UpdateCards()
    end)

    local temporaryTokensLocation = Location.Get(playerPrefix.." Temporary Tokens")
    temporaryTokensLocation:AddDropHandler(function(object)
        player:UpdateStats()
    end)
    temporaryTokensLocation:AddPickUpHandler(function(object)
        checkUnregisterCollisions(object)
        player:UpdateStats()
    end)

    local permanentTokensLocation = Location.Get(playerPrefix.." Permanent Tokens")
    permanentTokensLocation:AddDropHandler(function(object)
        player:UpdateStats()
    end)
    permanentTokensLocation:AddPickUpHandler(function(object)
        checkUnregisterCollisions(object)
        player:UpdateStats()
    end)

    return player
end

---------------------------------------------------------------------------------------------------

function Player.InitUi(player)
    local ui = Ui.Create3d("Player"..player.ordinal, player.boardObject, 0.11)
    player.ui = ui

    local x1 = -0.120503
    local y1 = -0.971472
    local x2 = -0.257252
    local y2 = -0.838162
    local xn = -0.842982
    local width = x2 - x1
    local dx = (xn - x1) / 4
    player.armorCounters = {}
    for i, hitLocation in ipairs(Player.HIT_LOCATIONS) do
        local topLeft = { x = x1 + (i - 1) * dx, y = y1 }
        local bottomRight = { x = topLeft.x + width, y = y2 }
        player.armorCounters[hitLocation] = ui:Counter({ id = hitLocation.."Armor", topLeft = topLeft, bottomRight = bottomRight, fontSize = 95, onValueChanged = function(delta)
            player.temporaryArmor[hitLocation] = player.temporaryArmor[hitLocation] + delta
            player:UpdateGear()
        end })
    end

     player.lightInjuryCheckBoxes = {}
     local x1 = -0.314098
     local y1 = -0.775458
     local x2 = -0.363223
     local y2 = -0.723353
     local xn = -0.855320
     local width = x2 - x1
     local dx = (xn - x1) / 3
     for i, hitLocation in ipairs({ "arms", "body", "waist", "legs" }) do
         local topLeft = { x = x1 + (i - 1) * dx, y = y1 }
         local bottomRight = { x = topLeft.x + width, y = y2 }
         player.lightInjuryCheckBoxes[hitLocation] = ui:CheckBox({ id = hitLocation.."LightInjury", topLeft = topLeft, bottomRight = bottomRight, checked = player.lightInjuries[hitLocation], onClick = function()
             local value = not player.lightInjuries[hitLocation]
             player.lightInjuries[hitLocation] = value
             player.lightInjuryCheckBoxes[hitLocation]:Check(value)
         end })
     end

     local x1 = -0.166245
     player.heavyInjuryCheckBoxes = {}
     player.heavyInjuryCheckBoxes.head = ui:CheckBox({ id = "headHeavyInjury", topLeft = { x = x1, y = y1 }, bottomRight = { x = x1 + width, y = y2 }, checked = player.heavyInjuries.head, onClick = function()
         local value = not player.heavyInjuries.head
         player.heavyInjuries.head = value
         player.heavyInjuryCheckBoxes.head:Check(value)
     end })
     local x1 = -0.376100
     local xn = -0.918347
     local dx = (xn - x1) / 3
     for i, hitLocation in ipairs({ "arms", "body", "waist", "legs" }) do
         local topLeft = { x = x1 + (i - 1) * dx, y = y1 }
         local bottomRight = { x = topLeft.x + width, y = y2 }
         player.heavyInjuryCheckBoxes[hitLocation] = ui:CheckBox({ id = hitLocation.."HeavyInjury", topLeft = topLeft, bottomRight = bottomRight, checked = player.heavyInjuries[hitLocation], onClick = function()
             local value = not player.heavyInjuries[hitLocation]
             player.heavyInjuries[hitLocation] = value
             player.heavyInjuryCheckBoxes[hitLocation]:Check(value)
         end })
     end

     ui:Button({ id = "healAndReset", topLeft = { x = -0.124014, y = -0.687478 }, bottomRight = { x = -0.323673, y = -0.596463 }, onClick = function()
         player:HealAndReset()
     end })

     ui:Button({ id = "backToSettlement", topLeft = { x = 0.910594, y = -0.139250 }, bottomRight = { x = 0.707226, y = -0.048424 }, onClick = function()
         player:BackToSettlement()
     end })

     ui:ApplyToObject()

    return player
end

---------------------------------------------------------------------------------------------------

function Player:__tostring()
    return Util.SafeFormat("Player{ordinal=%s}", self.ordinal)
end

---------------------------------------------------------------------------------------------------

function Player:Ordinal() return self.ordinal end
function Player:SurvivorSheet() return self.survivorSheet end

---------------------------------------------------------------------------------------------------

function Player:UpdateGear()
    local weaponsAndModifiers = {}

    local armorTotals = {}
    for _, hitLocation in ipairs(Player.HIT_LOCATIONS) do
        armorTotals[hitLocation] = self.temporaryArmor[hitLocation]
    end

    local playerPrefix = "Player "..self.ordinal
    for _, location in ipairs({
        playerPrefix.." Gear 1",
        playerPrefix.." Gear 2",
        playerPrefix.." Gear 3",
        playerPrefix.." Gear 4",
        playerPrefix.." Gear 5",
        playerPrefix.." Gear 6",
        playerPrefix.." Gear 7",
        playerPrefix.." Gear 8",
        playerPrefix.." Gear 9",
        playerPrefix.." Fist & Tooth",
        playerPrefix.." Armor Set",
    }) do
        local weaponAndModifiers = {
            weapon = nil,
            modifiers = {},
        }

        for _, object in ipairs(Location.Get(location):AllObjects()) do
            local objectName = object.GetName()
            if object.tag == "Card" then
                local armor = Armor.Get(objectName)
                if armor then
                    log:Debugf("Adding armor %s at %s", objectName, location)
                    for _, hitLocation in ipairs(Player.HIT_LOCATIONS) do
                        armorTotals[hitLocation] = armorTotals[hitLocation] + armor[hitLocation]
                    end
                end

                local weapon = Weapon.Get(objectName)
                if weapon then
                    log:Debugf("Adding weapon %s at %s", objectName, location)
                    weaponAndModifiers.weapon = weapon
                end
            else
                local stat = Player.TOKEN_STATS[objectName]
                if stat then
                    log:Debugf("Adding token %s for weapon at %s", objectName, location)
                    weaponAndModifiers.modifiers[stat] = (weaponAndModifiers.modifiers[stat] or 0) + Util.TokenValue(object)
                    object.registerCollisions()
                end
            end
        end

        if weaponAndModifiers.weapon then
            table.insert(weaponsAndModifiers, weaponAndModifiers)
        end
    end

    log:Debugf("Final %s weapons: %s", self, Util.TabStr(weapons))
    log:Debugf("Final %s armor: %s", self, Util.TabStr(armorTotals))

    self.weaponsAndModifiers = weaponsAndModifiers    -- purely a concession to make BattleUi updates easier

    for _, hitLocation in ipairs(Player.HIT_LOCATIONS) do
        self.armorCounters[hitLocation]:SetText(armorTotals[hitLocation])
    end

    EventManager.FireEvent(EventManager.ON_PLAYER_WEAPONS_CHANGED, self, weapons)
end

function Player:WeaponsAndModifiers() return self.weaponsAndModifiers end

---------------------------------------------------------------------------------------------------

function Player:UpdateCards()
    if not self.survivorSheet then
        return
    end

    log:Debugf("Updating %s cards", self)

    local cards = {}
    local positionsByCardNameType = {}
    for _, object in ipairs(Location.Get("Player "..self.ordinal.." Cards"):AllObjects()) do
        if object.tag == "Card" or object.tag == "Deck" then
            local container = Container(object)
            for _, card in ipairs(container:Objects()) do
                if Survivor.ALLOWED_CARD_TYPES[card.gm_notes] then
                    table.insert(cards, {
                        name = card.name,
                        type = card.gm_notes,
                    })

                    local nameType = (card.name or "")..card.gm_notes
                    local worldPosition = container:Object().getPosition()
                    local localPosition = self.boardObject.positionToLocal(worldPosition)
                    log:Debugf("Found card %s at world (%f, %f %f), local (%f, %f, %f)", card.name, worldPosition.x, worldPosition.y, worldPosition.z, localPosition.x, localPosition.y, localPosition.z)
                    if positionsByCardNameType[nameType] then
                        table.insert(positionsByCardNameType[nameType], localPosition)
                    else
                        positionsByCardNameType[nameType] = { localPosition }
                    end
                end
            end
        end
    end

    self.survivorSheet:Survivor():SetCards(cards)
    self.survivorSheet:Survivor():SetPositionsByCardNameType(positionsByCardNameType)
end

---------------------------------------------------------------------------------------------------

function Player:UpdateStats()
    if not self.survivorSheet then
        return
    end

    local modifiers = {}
    for _, object in ipairs(Location.Get("Player "..self.ordinal.." Temporary Tokens"):AllObjects()) do
        if object.getGMNotes() == "Tokens" then
            local stat = Player.TOKEN_STATS[object.getName()]
            if stat then
                local value = Util.TokenValue(object)
                log:Debugf("Found temporary token %s=%d for player %s", object.getName(), value, self)
                modifiers[stat] = (modifiers[stat] or 0) + value
                object.registerCollisions()
            end
        end
    end

    for _, object in ipairs(Location.Get("Player "..self.ordinal.." Permanent Tokens"):AllObjects()) do
        if object.getGMNotes() == "Tokens" then
            local stat = Player.TOKEN_STATS[object.getName()]
            if stat then
                local value = Util.TokenValue(object)
                log:Debugf("Found permanent token %s=%d for player %s", object.getName(), value, self)
                modifiers[stat] = (modifiers[stat] or 0) + value
                object.registerCollisions()
            end
        end
    end

    self.survivorSheet:Survivor():SetModifiers(modifiers)
end

---------------------------------------------------------------------------------------------------

function Player:HealAndReset()
    -- Clear temporary armor
    for i, hitLocation in ipairs(Player.HIT_LOCATIONS) do
        self.temporaryArmor[hitLocation] = 0
    end
    self:UpdateGear()

    -- Clear injuries
    for i, hitLocation in ipairs({ "arms", "body", "waist", "legs" }) do
        self.lightInjuries[hitLocation] = nil
        self.lightInjuryCheckBoxes[hitLocation]:Check(nil)
    end
    for i, hitLocation in ipairs(Player.HIT_LOCATIONS) do
        self.heavyInjuries[hitLocation] = nil
        self.heavyInjuryCheckBoxes[hitLocation]:Check(nil)
    end

    -- Clear temporary tokens
    for _, object in ipairs(Location.Get("Player "..self.ordinal.." Temporary Tokens"):AllObjects("Tokens")) do
        if object.getGMNotes() == "Tokens" and Player.TOKENS[object.getName()] then
            object.destruct()
        end
    end

    -- Reset survivor sheet
    if self.survivorSheet then
        local survivor = self.survivorSheet:Survivor()
        survivor:SetModifiers()
        survivor:SetBrainInjury(nil)
    end
end


---------------------------------------------------------------------------------------------------

function Player:OnObjectDroppedOnSurvivorSheet(object)
    if object.getGMNotes() != "Survivor Box" then
        return
    end

    if self.survivorSheet then
        return log:Broadcastf("Player %d is already linked to a survivor. Click the 'Back to Settlement' button to unlink, then try dropping the survivor box again.", self.ordinal)
    end

    local survivorBox = Survivor.SurvivorBoxForObject(object)
    if not survivorBox then
        return log:Errorf("Survivor box %s isn't linked to any survivor. This usually means it was created by copying/pasting or importing from another save, which won't work. If this is the case, then you'll need to create the survivor from the 'Survivors' board.", object.getGUID())
    end

    self:UnpackSurvivorBox(survivorBox)
end

---------------------------------------------------------------------------------------------------

function Player:UnpackSurvivorBox(survivorBox)
    log:Debugf("Unpacking %s for %s", survivorBox, self)

    local playerPrefix = "Player "..self.ordinal

    local blockingObjects = Location.Get(playerPrefix.." Cards"):AllObjects()
    if #blockingObjects > 0 then
        log:Printf("Please clear the cards area then re-drop the survivor box.")
        Util.HighlightAll(blockingObjects)
        return false
    end

    local survivor = survivorBox:Survivor()

    local countsByCardNameType = {}
    for _, card in ipairs(survivor:Cards()) do
        local nameType = card.name..card.type
        countsByCardNameType[nameType] = (countsByCardNameType[nameType] or 0) + 1
    end

    -- make a copy since we'll modify this
    local positionsByCardNameType = {}
    for cardName, positions in pairs(survivor:PositionsByCardNameType()) do
        positionsByCardNameType[cardName] = Util.CopyArray(positions)
    end

    local availableLocations = {
        [Location.Get(playerPrefix.." Fighting Art 1")] = true,
        [Location.Get(playerPrefix.." Fighting Art 2")] = true,
        [Location.Get(playerPrefix.." Fighting Art 3")] = true,
        [Location.Get(playerPrefix.." Disorder 1")] = true,
        [Location.Get(playerPrefix.." Disorder 2")] = true,
        [Location.Get(playerPrefix.." Disorder 3")] = true,
        [Location.Get(playerPrefix.." Weapon Proficiency")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 1")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 2")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 3")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 4")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 5")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 6")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 7")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 8")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 9")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 10")] = true,
        [Location.Get(playerPrefix.." Ability/Impairment 11")] = true,
    }

    local survivorBoxContainer = Container(survivorBox:Object())
    for _, entry in ipairs(survivorBoxContainer:Objects()) do
        if entry.gm_notes == "Player Figurine" then
            log:Debugf("Unpacking figurine %s to self marker", entry.guid)
            local figurineObject = survivorBoxContainer:Take({
                guid = entry.guid,
                location = playerPrefix.." Marker",
            })
            self:LinkFigurine(figurineObject)

        else
            local nameType = (entry.name or "")..(entry.gm_notes or "")
            if (countsByCardNameType[nameType] or 0) > 0 then
                countsByCardNameType[nameType] = countsByCardNameType[nameType] - 1

                local position = nil
                local count = #(positionsByCardNameType[nameType] or {})
                if count > 0 then
                    position = self.boardObject.positionToWorld(positionsByCardNameType[nameType][count])
                    table.remove(positionsByCardNameType[nameType])

                    log:Debugf("Unpacking card %s/%s to (%f, %f, %f)", entry.name, entry.gm_notes, position.x, position.y, position.z)
                    survivorBoxContainer:Take({
                        guid = entry.guid,
                        position = position,
                        rotation = { x = 0, y = 180, z = 0 },
                    })

                    for _, location in ipairs(Location.LocationsAtPosition(position)) do
                        log:Debugf("Card %s/%s now occupies %s", entry.name, entry.gm_notes, location)
                        availableLocations[location] = nil
                    end
                else
                    log:Debugf("Card %s doesn't have position", entry.name)
                end
            else
                log:Debugf("Unrecognized object in %s: %s/%s", survivorBox, entry.name, entry.gm_notes)
            end
        end
    end

    local overflowLocation = Location.Get(playerPrefix.." Ability/Impairment 11")
    local extraObjects = false
    local height = 2 + 0.5
    for _, entry in ipairs(survivorBoxContainer:Objects()) do
        local location = Player:TakeNextLocation(playerPrefix, entry.gm_notes, availableLocations)
        if not location then
            log:Errorf("No more space to place %s separately!", entry.name)
            location = overflowLocation
            extraObjects = true
        end

        log:Debugf("Taking %s (%s) to %s", entry.name, entry.guid, location)
        survivorBoxContainer:Take({
            guid     = entry.guid,
            location = location,
            height   = height,
        })
        height = height + 0.5
    end

    if extraObjects then
        log:Errorf("Some items couldn't be placed separately and have been stacked on the lower-right card slot of your survivor sheet.")
        overflowLocation:BoxCast({ debug = true })
    end

    local survivorSheet = Survivor.SurvivorSheetForSurvivor(survivorBox:Survivor())
    if survivorSheet then
        log:Debugf("%s already exists, destroying and recreating", survivorSheet)
        survivorSheet:Object().destruct()
    end

    Archive.Take({ name = "Survivor Sheet", type = "Survivor Sheet", location = playerPrefix.." Survivor Sheet", height = 0, rotation = { x = 0, y = 180, z = 0 }, spawnFunc = function(survivorSheetObject)
        -- We have to wait a single frame when taking from an infinite container or the objects will have the same equality/identity value as any other objects taken that frame
        Wait.frames(function()
            log:Debugf("Created survivor sheet for object %s and %s", survivorSheetObject.getGUID(), survivorBox:Survivor())
            local survivorSheet = Survivor.CreateSurvivorSheet(survivorBox:Survivor(), survivorSheetObject)
            survivorSheetObject.setLock(true)
            survivorBox:Object().destruct()
            self:LinkSurvivorSheet(survivorSheet)
        end, 1)
    end })

    return true
end

---------------------------------------------------------------------------------------------------

function Player:TakeNextLocation(playerPrefix, gmNotes, availableLocations)
    if gmNotes == "Disorders" then
        for i = 1, 3 do
            local key = Location.Get(playerPrefix.." Disorder "..i)
            if availableLocations[key] then
                availableLocations[key] = nil
                return key
            end
        end

    elseif gmNotes == "Fighting Arts" or gmNotes == "Secret Fighting Arts" then
        for i = 1, 3 do
            local key = Location.Get(playerPrefix.." Fighting Art "..i)
            if availableLocations[key] then
                availableLocations[key] = nil
                return key
            end
        end

    elseif gmNotes == "Weapon Proficiencies" then
        local key = Location.Get(playerPrefix.." Weapon Proficiency")
        if availableLocations[key] then
            availableLocations[key] = nil
            return key
        end
    end

    for i = 1, 11 do
        local key = Location.Get(playerPrefix.." Ability/Impairment "..i)
        if availableLocations[key] then
            availableLocations[key] = nil
            return key
        end
    end
end

---------------------------------------------------------------------------------------------------

function Player:LinkSurvivorSheet(survivorSheet)
    assert(Check(self.survivorSheet == nil, "%s is already linked to %s", self, self.survivorSheet))

    log:Debugf("Linking %s to %s", survivorSheet, self)

    self.survivorSheet = survivorSheet
    if self.figurineObject then
        local name = survivorSheet:Survivor():NameOrUnnamed()
        log:Debugf("Setting linked figurine %s name to %s", self.figurineObject.getGUID(), name)
        self.figurineObject.setName(name)
    end

    Wait.frames(function()
        -- the survivor sheet object may have been created this turn, in which case we must wait X frames
        -- before updating any XML UI elements
        self:UpdateStats()
    end, 20)

    self:UpdateCards()

    EventManager.FireEvent(EventManager.ON_PLAYER_SURVIVOR_LINKED, self, survivorSheet:Survivor())
end

---------------------------------------------------------------------------------------------------

function Player:UnlinkSurvivorSheet()
    local survivorSheet = self.survivorSheet
    local survivor = survivorSheet:Survivor()
    log:Debugf("Unlinking %s from %s", survivorSheet, self)
    survivor:SetModifiers()
    self.survivorSheet = nil
    EventManager.FireEvent(EventManager.ON_PLAYER_SURVIVOR_UNLINKED, self, survivor)
end

---------------------------------------------------------------------------------------------------

function Player:BackToSettlement()
    local survivorSheet = self.survivorSheet
    if survivorSheet == nil then
        return log:Debugf("No survivor linked with %s", self)
    end

    local survivor = survivorSheet:Survivor()

    log:Debugf("Returning %s on %s to settlement", survivorSheet, self)

    self:UnlinkSurvivorSheet()

    local remainingObjects = {}
    for _, object in ipairs(Location.Get("Player "..self.ordinal.." Cards"):AllObjects()) do
        if object.tag == "Card" or object.tag == "Deck" then
            local container = Container(object)
            local toDelete = {}
            for _, entry in ipairs(container:Objects()) do
                if Survivor.ALLOWED_CARD_TYPES[entry.gm_notes] then
                    log:Debugf("Deleting %s/%s", entry.name, entry.gm_notes)
                    table.insert(toDelete, entry.name)
                end
            end
            container:Delete(toDelete)
        else
            table.insert(remainingObjects, objects)
        end
    end

    if #remainingObjects > 0 then
        log:Errorf("Some cards or objects were not returned with the self to the settlement. Please record these manually.")
        Util.HighlightAll(remainingObjects)
    end

    survivorSheet:Object().destruct()

    log:Printf("Returned %s to settlement", survivor:NameOrUnnamed())
end

---------------------------------------------------------------------------------------------------

function Player:LinkFigurine(figurineObject)
    self:UnlinkFigurine()

    for _, otherPlayer in ipairs(Player.players) do
        if otherPlayer.figurineObject == figurineObject then
            otherPlayer:UnlinkFigurine()
        end
    end

    log:Debugf("Linking figurine [%s] %s to %s", figurineObject.getGUID(), figurineObject.getName(), self)
    figurineObject.setColorTint(self.markerObject.getColorTint())
    if self.survivorSheet then
        local name = self.survivorSheet:Survivor():NameOrUnnamed()
        figurineObject.setName(name)
        log:Printf("Linked figurine to player %s (%s)", self.ordinal, name)
    else
        log:Printf("Linked figurine to player %s", self.ordinal)
    end

    self.figurineObject = figurineObject
end

---------------------------------------------------------------------------------------------------

function Player:UnlinkFigurine()
    local figurineObject = self.figurineObject
    if not figurineObject then
        return
    end

    log:Debugf("Unlinking figurine [%s] %s) from %s", figurineObject.getGUID(), figurineObject.getName(), self)
    figurineObject.setName("Unnamed Survivor")
    figurineObject.setColorTint({ r = 0, g = 0, b = 0 })
    self.figurineObject = nil
end

---------------------------------------------------------------------------------------------------

function Player:FigurineObject()
    return self.figurineObject
end

---------------------------------------------------------------------------------------------------

return {
    Is = Player.Is,
    Create = Player.Create,
    Init = Player.Init,
    PostInit = Player.PostInit,
    Save = Player.Save,
    Players = function() return Player.players end,
    ForFigurine = Player.ForFigurine,
}
